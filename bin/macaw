#!/usr/bin/env ruby

require 'yaml'
require 'pp'
require_relative '../lib/macaw'
require_relative '../lib/macaw/version'
require 'json/pure'
require 'os'
require 'shellwords'
require 'optparse'
require 'timeout'
require 'i18n'

def error(msg)
  puts msg
  exit 1
end

puts [
' __  __                          ',
'|  \/  | __ _  ___ __ ___      __',
'| |\/| |/ _` |/ __/ _` \ \ /\ / /',
'| |  | | (_| | (_| (_| |\ V  V / ',
'|_|  |_|\__,_|\___\__,_| \_/\_/  ',
'                                 ',
].join("\n")

CONTRIBUTORS = [
  'Alan Munn',
  'Andrew Stacey',
  'Brent Longborough',
  'Clemens Niederberger',
  'David Carlisle',
  'Enrico Gregorio',
  'Francesco Endrici',
  'Gonzalo Medina',
  'Harish Kumar',
  '?lhan Polat',
  'Joseph Wright',
  'Marco Daniel',
  'MikaÎ´l Maunier',
  'Patrick Gundlach',
  'Rasmus Roulund',
  'Sergey Ulyanov',
  'Stefan Kottwitz'
].join(', ')

I18n.enforce_available_locales = true
I18n.load_path = Dir[File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib', 'macaw', 'i18n', '*.yml'))]
I18n.default_locale = :en

def options!
  [true, false].collect{|dryrun|
    opts = OptionParser.new{|parser|
      parser.banner = "#{I18n.t('help.usage')}: macaw [options] FILE"
      parser.separator ""

      parser.on('-L', '--language LANG', I18n.t('help.language')){|lang|
        begin
          I18n.locale = lang.intern
        rescue I18n::InvalidLocale
          if !dryrun
            puts "#{lang.inspect} is not among the supported languages #{I18n.available_locales.inspect}"
            exit
          end
        end
      }

      parser.on('-l', '--log', I18n.t('help.log'))

      parser.on('-t', '--timeout SECONDS', I18n.t('help.timeout')){|timeout|
        Integer(timeout)
      }

      parser.on('-v', '--verbose', I18n.t('help.verbose'))

      parser.on_tail('-h', '--help', '--usage', I18n.t('help.help')){
        if !dryrun
          puts parser.help
          exit
        end
      }

      parser.on_tail('-V', '--version', I18n.t('help.version')){
        if !dryrun
          puts "macaw #{Macaw::VERSION} - The cool TeX automation tool\nCopyright (c) 2012, Paulo Roberto Massa Cereda\n"
          puts I18n.t('help.rights')
          puts "\n"
          puts I18n.t('help.thanks').sub('CONTRIBUTORS', CONTRIBUTORS).gsub(/(.{1,#{60}})(?: +|$)\n?|(.{#{60}})/, "\\1\\2\n")
          exit
        end
      }
    }
    if dryrun
      opts.parse!(ARGV.dup)
    else
      opts.parse!
    end
  }.last
end

OPTS=options!

error("No filename to process") if ARGV.size == 0
error("Expected exactly one filename to process #{ARGV.inspect}") if ARGV.size != 1
if File.file?(ARGV[0])
  TEX = ARGV[0]
elsif File.file?(ARGV[0] + '.tex')
  TEX = ARGV[0] + '.tex'
else
  error("#{ARGV[0].inspect} does not exist") if !File.exists?(ARGV[0])
end

CONFIGFILE = [File.join(Dir.home, 'araraconfig.yaml'), File.join(Dir.home, '.araraconfig.yaml')].detect{|config| File.file?(config) }
CONFIG = CONFIGFILE ? YAML.load_file(CONFIGFILE) : {}

class String
  def ~
    if OS.windows?
      return '"' + self.gsub('"', '""') + '"'
    else
      return self.shellescape
    end
  end
end

class JSON::Pure::Parser
  IDENTIFIER = /[^:\s\\",{}\[\]]+/i
  alias :parse_quoted_string :parse_string

  def parse_string
    if match?(IDENTIFIER)
      str = scan(IDENTIFIER)
      return true if str == 'yes'
      return false if str == 'no'
      return str
    end

    return parse_quoted_string
  end
end

class Macaw
  @@log = nil

  def initialize(tex)
    @file = tex
    @base = File.basename(@file, File.extname(@file))
  end
  attr_reader :file, :base

  def self.run(file)
    Macaw.load_rules
    macaw = Macaw.new(file)
    @@log = File.open(@base + '.log') if OPTS[:log]

    IO.readlines(file).each{|line|
      next unless line =~ /^% arara: /
      line.strip!
      line.sub!(/^%\s+arara\s*:\s*/, '')
      data = line.split(':', 2).collect{|v| v.strip}

      cmd = data[0]
      next if cmd == ''

      error 'Halted on user request' if cmd == 'halt'

      params = {}
      begin
        params = JSON.parse(data[1]) if data[1]
      rescue => e
        error("cannot parse command #{line.inspect}: #{e}")
      end

      cmd = cmd.intern

      error "no such rule #{cmd}" unless macaw.respond_to?(cmd)

      accept = Macaw.instance_method(cmd).parameters
      required = accept.collect{|k, v| k == :req ? v : nil}.compact
      optional = accept.collect{|k, v| k != :req ? v : nil}.compact

      missing = required - params.keys.collect{|k| k.intern}
      error "#{line}: missing required parameter#{missing.size > 1 ? 's' : ''}: #{missing.inspect}" if missing.size > 0

      unexpected = params.keys.collect{|k| k.intern} - (required + optional)
      error "#{line}: unexpected parameter#{unexpected.size > 1 ? 's' : ''}: #{unexpected.inspect}" if unexpected.size > 0

      macaw.send(cmd, *accept.collect{|k, v| params[v.to_s]})
    }
  end

  def self.system(cmd)
    cmd = cmd.compact.join(' ') if cmd.is_a?(Array)
    puts cmd

    output = ''
    begin
      if OPTS[:timeout]
        Timeout::timeout(OPTS[:timeout]) { output = `#{cmd}` }
      else
        output = `#{cmd}`
      end
    rescue Timeout::Error
      throw "#{cmd}: timed out after #{OPTS[:timeout]} seconds"
    end

    @@log.write(output) if @@log
    print output if OPTS[:verbose]
    return output if $?.to_i == 0
    throw "#{cmd}: #{$?}"
  end

  def self.load_rules
    CONFIG['paths'].each{|path| puts path; require_all path} if CONFIG['paths']
  end
end

Macaw.run(TEX)
